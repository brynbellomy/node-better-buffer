// Generated by CoffeeScript 1.3.1
var Buffer,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

Buffer = require("buffer").Buffer;

/*
# class BetterBuffer

`Buffer` subclass with some really obvious add-ons.  Made this while working on
an app for #Occupy, so maybe it really *is* a "better" `Buffer` (sigh).
*/


exports.BetterBuffer = (function(_super) {

  __extends(BetterBuffer, _super);

  BetterBuffer.name = 'BetterBuffer';

  BetterBuffer.prototype.growSize = 512;

  BetterBuffer.prototype.dataLength = 0;

  /* Object constructor.  Calls core `Buffer` constructor.
   @param {(number)} initialSize: the initial size of the buffer, passed straight to the core node.js `Buffer` constructor.
   @param {(number)} _growSize
  */


  function BetterBuffer(initialSize, _growSize) {
    this.popFront = __bind(this.popFront, this);

    this.cloneDataIntoNewBuffer = __bind(this.cloneDataIntoNewBuffer, this);

    this.pushBack = __bind(this.pushBack, this);

    this.growToAccommodate = __bind(this.growToAccommodate, this);

    this.getNextSmallestBufferSize = __bind(this.getNextSmallestBufferSize, this);
    Buffer.call(this, initialSize);
    if (_growSize != null) {
      this.growSize = _growSize;
    }
  }

  /* Finds the smallest possible capacity that can hold `dataLengthToAccommodate`
      and that is also a multiple of the buffer's `growSize` setting.
   @param {(number)} dataLengthToAccommodate: The number of octets the buffer must guarantee being able to accommodate.
  */


  BetterBuffer.prototype.getNextSmallestBufferSize = function(dataLengthToAccommodate) {
    return this.growSize * (Math.floor(dataLengthToAccommodate / this.growSize) + 1);
  };

  /* Enlarge the buffer in increments specified by its `growSize` member.
   @param {(number)} dataLengthToAccommodate: The number of octets the buffer must guarantee being able to accommodate.
  */


  BetterBuffer.prototype.growToAccommodate = function(dataLengthToAccommodate) {
    var expandedBuffer, newSize;
    if (dataLengthToAccommodate > this.length) {
      newSize = this.getNextSmallestBufferSize(dataLengthToAccommodate);
      expandedBuffer = new BetterBuffer(newSize);
      this.copy(expandedBuffer);
      BetterBuffer.call(this, newSize, this.growSize);
      expandedBuffer.copy(this);
    }
    return this;
  };

  /* Append the contents of `sourceBuffer` to the buffer.  The insertion point is the
      "end" of the buffer, as defined by the buffer's `dataLength` parameter.  The buffer
      is not enlarged if the contents of `sourceBuffer` exceeds the current capacity.
   @param {(Buffer)} sourceBuffer: The buffer to append.
   @return {(number)} The new value of `this.dataLength`.
  */


  BetterBuffer.prototype.pushBack = function(sourceBuffer) {
    sourceBuffer.copy(this, this.dataLength);
    this.dataLength = Math.min(this.length, this.dataLength + sourceBuffer.length);
    return this.dataLength;
  };

  /* Creates a new `BetterBuffer` containing an exact copy of the contents of the
      buffer.  __NOTE:__ the returned buffer's size is equal to the source buffer's
      `dataLength` property, not its `length` property.
   @return {(BetterBuffer)} A new buffer containing the cloned octets.
  */


  BetterBuffer.prototype.cloneDataIntoNewBuffer = function() {
    var outBuffer;
    outBuffer = new BetterBuffer(this.dataLength, this.growSize);
    this.copy(outBuffer, 0, 0, this.dataLength);
    return outBuffer;
  };

  /* Just a simple `pop` function, like you'd find on a stack or queue.  Hacks off the
      first `num` octets in the buffer, shifts everything in the buffer forward by the
      same distance, and returns the popped octets in a new `BetterBuffer` object.
  
      The buffer's `dataLength` property is decremented accordingly.
  
   @param {(number)} num: The number of octets to pop and return.
   @return {(BetterBuffer)} A new buffer containing the popped octets.
  */


  BetterBuffer.prototype.popFront = function(num) {
    var meBuffer, newDataLength, newSize, outBuffer;
    newSize = this.length - num;
    outBuffer = new BetterBuffer(num);
    meBuffer = new BetterBuffer(newSize);
    newDataLength = Math.max(0, this.dataLength - num);
    this.copy(outBuffer, 0, 0, num);
    this.copy(meBuffer, 0, num, this.length);
    BetterBuffer.call(this, newSize, this.growSize);
    meBuffer.copy(this);
    this.dataLength = newDataLength;
    return outBuffer;
  };

  return BetterBuffer;

})(Buffer);
